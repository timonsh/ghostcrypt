# GhostCrypt API Dokumentation

## `ghost()` - Hauptfunktion

Die zentrale Funktion f√ºr alle GhostCrypt-Operationen (Verschl√ºsselung, Entschl√ºsselung, Keyfile-Generierung).

---

## Syntax

```javascript
await ghost(options)
```

---

## Parameter

### `options` (Object) - Erforderlich

| Property | Typ | Erforderlich | Beschreibung |
|----------|-----|--------------|--------------|
| `action` | String | ‚úÖ Ja | `'encrypt'` \| `'decrypt'` \| `'generate_keyfile'` |
| `file` | File \| ArrayBuffer | ‚ö†Ô∏è F√ºr encrypt/decrypt | Datei zum Verschl√ºsseln/Entschl√ºsseln |
| `key_method` | String | ‚ö†Ô∏è F√ºr encrypt/decrypt | `'password'` \| `'keyfile'` |
| `password` | String | ‚ö†Ô∏è Wenn key_method = password | Passwort f√ºr Ver-/Entschl√ºsselung |
| `keyfile` | ArrayBuffer | ‚ö†Ô∏è F√ºr decrypt mit keyfile | Keyfile-Inhalt als ArrayBuffer |
| `on_progress` | Function | ‚ùå Optional | Callback f√ºr Fortschritts-Updates |
| `on_error` | Function | ‚ùå Optional | Callback f√ºr Fehler |
| `on_complete` | Function | ‚ùå Optional | Callback bei Abschluss |

---

## R√ºckgabewert

**Promise** ‚Üí L√∂st auf mit Ergebnis-Objekt:

### Bei Erfolg:
```javascript
{
    success: true,
    action: 'encrypt' | 'decrypt' | 'generate_keyfile',
    message: 'Erfolgs-Nachricht',
    // ... weitere Details je nach Action
}
```

### Bei Fehler:
```javascript
{
    success: false,
    action: 'encrypt' | 'decrypt' | 'generate_keyfile',
    error: 'Fehlermeldung'
}
```

---

## Verwendungsbeispiele

### 1. Datei mit Passwort verschl√ºsseln

```javascript
const fileInput = document.querySelector('#file-input');
const file = fileInput.files[0];

await ghost({
    action: 'encrypt',
    file: file,
    key_method: 'password',
    password: 'MySecurePassword123',
    
    on_progress: (status, ui_status) => {
        console.log('Status:', ui_status);
        // Update UI hier
    },
    
    on_complete: (result) => {
        console.log('‚úÖ Verschl√ºsselung abgeschlossen!');
        console.log('Original:', result.original_size, 'Bytes');
        console.log('Verschl√ºsselt:', result.encrypted_size, 'Bytes');
        alert('Datei erfolgreich verschl√ºsselt! üëª');
    },
    
    on_error: (error) => {
        console.error('‚ùå Fehler:', error);
        alert('Fehler: ' + error);
    }
});
```

---

### 2. Datei mit Passwort entschl√ºsseln

```javascript
const ghostFileInput = document.querySelector('#ghost-file-input');
const ghostFile = ghostFileInput.files[0];

await ghost({
    action: 'decrypt',
    file: ghostFile,
    key_method: 'password',
    password: 'MySecurePassword123',
    
    on_progress: (status, ui_status) => {
        document.querySelector('#status').textContent = ui_status;
    },
    
    on_complete: (result) => {
        console.log('‚úÖ Entschl√ºsselung erfolgreich!');
        console.log('Datei:', result.original_filename);
        alert('Datei entschl√ºsselt! üîì');
    },
    
    on_error: (error) => {
        alert('‚ùå Entschl√ºsselung fehlgeschlagen: ' + error);
    }
});
```

---

### 3. Keyfile generieren

```javascript
await ghost({
    action: 'generate_keyfile',
    
    on_complete: (result) => {
        console.log('‚úÖ Keyfile generiert!');
        console.log('Fingerprint:', result.key_material);
        alert('Keyfile wurde heruntergeladen! üîë');
    }
});
```

---

### 4. Mit Keyfile verschl√ºsseln

```javascript
// Keyfile wird automatisch generiert beim Verschl√ºsseln
await ghost({
    action: 'encrypt',
    file: myFile,
    key_method: 'keyfile',
    // KEIN password n√∂tig - Keyfile wird automatisch erstellt
    
    on_complete: (result) => {
        alert('Datei verschl√ºsselt! Keyfile wurde heruntergeladen.');
        console.log('Bewahre das Keyfile sicher auf!');
    }
});
```

---

### 5. Mit Keyfile entschl√ºsseln

```javascript
const ghostFile = ghostFileInput.files[0];
const keyfile = keyfileInput.files[0];

// Keyfile als ArrayBuffer laden
const keyfileArrayBuffer = await keyfile.arrayBuffer();

await ghost({
    action: 'decrypt',
    file: ghostFile,
    key_method: 'keyfile',
    keyfile: keyfile_array_buffer,
    
    on_complete: (result) => {
        alert('Mit Keyfile entschl√ºsselt! üîì');
    },
    
    on_error: (error) => {
        alert('Falsches Keyfile oder besch√§digte Datei!');
    }
});
```

---

### 6. Fortgeschrittenes Beispiel mit UI-Integration

```javascript
// HTML Button Handler
document.querySelector('#encrypt-btn').addEventListener('click', async () => {
    
    const file = document.querySelector('#file-input').files[0];
    const password = document.querySelector('#password-input').value;
    const progressBar = document.querySelector('#progress-bar');
    const statusText = document.querySelector('#status-text');
    
    if (!file) {
        alert('Bitte Datei ausw√§hlen!');
        return;
    }
    
    if (!password) {
        alert('Bitte Passwort eingeben!');
        return;
    }
    
    try {
        const result = await ghost({
            action: 'encrypt',
            file: file,
            key_method: 'password',
            password: password,
            
            on_progress: (technical_status, ui_status) => {
                statusText.textContent = ui_status;
                
                // Fortschrittsbalken updaten
                const progress_map = {
                    'KEY_DERIVATION': 20,
                    'GENERATING_IVS': 30,
                    'ENCRYPTING_AES': 50,
                    'ENCRYPTING_CHACHA': 70,
                    'CALCULATING_HMAC': 85,
                    'BUILDING_GHOST': 95,
                    'ENCRYPTION_COMPLETE': 100
                };
                
                const progress = progress_map[technical_status] || 0;
                progressBar.style.width = progress + '%';
            },
            
            on_complete: (result) => {
                statusText.textContent = '‚úÖ Fertig!';
                progressBar.style.width = '100%';
                
                const size_reduction = ((result.encrypted_size / result.original_size) * 100).toFixed(1);
                
                alert(`Verschl√ºsselung erfolgreich!\n\nOriginal: ${formatBytes(result.original_size)}\nVerschl√ºsselt: ${formatBytes(result.encrypted_size)}\nRatio: ${size_reduction}%`);
            },
            
            on_error: (error) => {
                statusText.textContent = '‚ùå Fehler!';
                progressBar.style.width = '0%';
                alert('Fehler: ' + error);
            }
        });
        
    } catch (error) {
        alert('Unerwarteter Fehler: ' + error.message);
    }
    
});

// Helper Funktion
function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}
```

---

## Callbacks

### `on_progress(technical_status, ui_status)`

Wird w√§hrend der Operation aufgerufen (throttled auf 2 Sekunden).

**Parameter:**
- `technical_status` (String): Technischer Status-Code (z.B. `'ENCRYPTING_AES'`)
- `ui_status` (String): Benutzerfreundliche Status-Nachricht (z.B. `'Geist entsteht...'`)

**Technische Status-Codes:**

**Verschl√ºsselung:**
- `KEY_DERIVATION` ‚Üí "Schl√ºssel werden abgeleitet..."
- `GENERATING_IVS` ‚Üí "Initialisierung..."
- `ENCRYPTING_AES` ‚Üí "Geist entsteht..."
- `ENCRYPTING_CHACHA` ‚Üí "Geist wird verst√§rkt..."
- `CALCULATING_HMAC` ‚Üí "Geist wird versiegelt..."
- `BUILDING_GHOST` ‚Üí "Geist materialisiert sich..."
- `ENCRYPTION_COMPLETE` ‚Üí "Geist entfesselt! üëª"

**Entschl√ºsselung:**
- `PARSING_GHOST` ‚Üí "Geist wird gelesen..."
- `DERIVING_KEYS_DECRYPT` ‚Üí "Schl√ºssel werden gepr√ºft..."
- `VERIFYING_HMAC` ‚Üí "Siegel wird √ºberpr√ºft..."
- `DECRYPTING_CHACHA` ‚Üí "Geist wird befreit..."
- `DECRYPTING_AES` ‚Üí "Geist wird enth√ºllt..."
- `DECRYPTION_COMPLETE` ‚Üí "Geist entschl√ºsselt! üîì"

---

### `on_error(error_message)`

Wird bei Fehler aufgerufen.

**Parameter:**
- `error_message` (String): Fehlermeldung

**M√∂gliche Fehler:**
- `"Ung√ºltige .ghost Datei"` - Magic bytes stimmen nicht
- `"Nicht unterst√ºtzte .ghost Version"` - Version ‚â† 1
- `"Falsches Passwort oder Keyfile"` - HMAC-Verifikation fehlgeschlagen
- `"Ung√ºltige .gkey Datei"` - Keyfile-Format ung√ºltig
- `"Keyfile konnte nicht gelesen werden"` - JSON-Parse-Fehler

---

### `on_complete(result)`

Wird bei erfolgreichem Abschluss aufgerufen.

**Parameter:**
- `result` (Object): Ergebnis-Objekt mit Details

---

## Fehlerbehandlung

```javascript
try {
    const result = await ghost({
        action: 'decrypt',
        file: ghostFile,
        key_method: 'password',
        password: wrongPassword
    });
    
    if (!result.success) {
        console.error('Operation fehlgeschlagen:', result.error);
    }
    
} catch (error) {
    console.error('Exception:', error.message);
}
```

---

## Sicherheitshinweise

‚ö†Ô∏è **Wichtig:**

1. **Passw√∂rter**: Mindestens 12 Zeichen, Sonderzeichen, Zahlen
2. **Keyfiles**: An sicherem Ort aufbewahren (offline!)
3. **Keyfile-Verlust**: Ohne Keyfile ist Entschl√ºsselung UNM√ñGLICH
4. **Quantum-Sicher**: AES-256 + ChaCha20 = Post-Quantum Ready
5. **Memory**: Gro√üe Dateien (>1GB) ben√∂tigen viel RAM

---

## Browser-Kompatibilit√§t

- ‚úÖ Chrome/Edge 90+
- ‚úÖ Firefox 88+
- ‚úÖ Safari 14+
- ‚úÖ Opera 76+

**Erforderliche APIs:**
- Web Crypto API (Browser-nativ)
- FileReader API (Browser-nativ)
- Blob/ArrayBuffer (Browser-nativ)

**Erforderliche Bibliotheken (aus `src/import/crypt/`):**
- `argon2.min.js` - Argon2 WebAssembly (v1.18.0+)
- `crypto-js.min.js` - CryptoJS f√ºr AES-256 & HMAC (v4.2.0+)
- `chacha20.min.js` - ChaCha20 Implementation (RFC 7539)

---

## Performance

| Dateigr√∂√üe | Verschl√ºsselungszeit | RAM-Bedarf |
|------------|---------------------|------------|
| 1 MB | ~0.5s | ~5 MB |
| 10 MB | ~2s | ~20 MB |
| 100 MB | ~15s | ~200 MB |
| 1 GB | ~2min | ~2 GB |

**Argon2id-Parameter:**
- Iterationen: 3
- Memory: 64 MB
- Parallelism: 4

---

## Erforderliche HTML-Einbindung

Um GhostCrypt zu verwenden, m√ºssen folgende Scripts in der HTML-Datei eingebunden werden:

```html
<!-- Krypto-Bibliotheken (in dieser Reihenfolge!) -->
<script src="src/import/crypt/argon2.min.js"></script>
<script src="src/import/crypt/crypto-js.min.js"></script>
<script src="src/import/crypt/chacha20.min.js"></script>

<!-- GhostCrypt Main -->
<script src="src/js/main.js"></script>
```

**Wichtig:** Die Bibliotheken m√ºssen VOR `main.js` geladen werden!

---

## Lizenz

GhostCrypt ¬© 2025 - WebByte Studio  
Military-Grade Encryption - Made in Germany üá©üá™üëª
