/* â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   â–ˆ                                                                                             â–ˆ
   â–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆ
   â–ˆ    â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•    â–ˆ
   â–ˆ    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘       â–ˆ
   â–ˆ    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•šâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•”â•â•â•â•    â–ˆâ–ˆâ•‘       â–ˆ
   â–ˆ    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘       â–ˆ
   â–ˆ     â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•   â•šâ•â•    â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•        â•šâ•â•       â–ˆ
   â–ˆ                                                                                             â–ˆ
   â–ˆ                               ðŸ‘» High-level encryption protocol ðŸ”                          â–ˆ
   â–ˆ                                                                                             â–ˆ
   â–ˆ                                            Version: 1.0                                     â–ˆ
   â–ˆ                                    Crafted by WEBBYTE STUDIO                                â–ˆ
   â–ˆ                        View GitHub: https://github.com/timonsh/ghostcrypt                   â–ˆ
   â–ˆ                                                                                             â–ˆ
   â–ˆ                           AES-256-CBC + ChaCha20 + Argon2id + HMAC-SHA512                   â–ˆ
   â–ˆ                                                                                             â–ˆ
   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ */

   /*
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  GHOSTCRYPT STANDALONE                                                                      â”‚
   â”‚                                                                                             â”‚
   â”‚  This is the minified standalone version requiring external dependencies:                   â”‚
   â”‚  â€¢ Argon2id - Password hashing (argon2.min.js)                                              â”‚
   â”‚  â€¢ ChaCha20 - Stream cipher (chacha20.min.js)                                               â”‚
   â”‚  â€¢ CryptoJS - AES-256 + HMAC (crypto-js.min.js)                                             â”‚
   â”‚                                                                                             â”‚
   â”‚  Documentation & setup guide:                                                               â”‚
   â”‚  â†’ https://github.com/timonsh/ghostcrypt                                                    â”‚
   â”‚                                                                                             â”‚
   â”‚  For plug-and-play usage without external dependencies:                                     â”‚
   â”‚  â†’ Use ghostcrypt-v1-bundle.min.js (all libraries included)                                 â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */

        
   "use strict";async function ghost(e,t){if("string"==typeof e){const r=e.toLowerCase();if("reset"===r)return encryptionAgent("initialize"),{success:!0,action:"reset",message:"Cache has been reset"};if("upload"===r){return"keyfile"===(t||"file")?await ghostcryptUploadKeyfile():await ghostcryptUploadFile()}if("download"===r){if("keyfile"===(t||"ghost")){if(ghostCache.generatedKeyfile){const e=(ghostCache.uploadedFile?.name?ghostCache.uploadedFile.name:"ghostcrypt-key")+".gkey";return downloadFile(ghostCache.generatedKeyfile,e),{success:!0,action:"download",type:"keyfile",filename:e,message:"Keyfile downloaded"}}throw new Error("GhostCrypt: No keyfile in cache to download")}if(ghostCache.ghost){const e=ghostCache.uploadedFile?.name?ghostCache.uploadedFile.name+".ghost":"GhostCryptRaw.ghost";return downloadFile(ghostCache.ghost,e),{success:!0,action:"download",type:"ghost",filename:e,size:ghostCache.ghost.byteLength,message:"Download successful"}}if(ghostCache.decryptedLayer2){let e=ghostCache.uploadedFile?.name||"GhostCryptRaw";return e.endsWith(".ghost")&&(e=e.slice(0,-6)),downloadFile(ghostCache.decryptedLayer2,e),{success:!0,action:"download",type:"file",filename:e,size:ghostCache.decryptedLayer2.byteLength,message:"Download successful"}}throw new Error("GhostCrypt: Nothing to download in cache")}throw new Error(`GhostCrypt: Unknown command "${e}". Use 'reset', 'upload', or 'download'`)}if(!e||"object"!=typeof e)throw new Error("GhostCrypt: Options must be an object or string command");const{action:r,file:o,content:a,keyMethod:s,password:n,keyfile:c,onProgress:i,onError:h,onComplete:d}=e;if(!["encrypt","decrypt","generateKeyfile"].includes(r))throw new Error(`GhostCrypt: Invalid action "${r}". Use 'encrypt', 'decrypt', or 'generateKeyfile'`);encryptionAgent("initialize");const l=updateStatus;i&&(window.updateStatus=function(e,t){l(e,t),i(e,t)});try{if("generateKeyfile"===r){if(encryptionAgent("generateKeyfile")){const e={success:!0,action:"generateKeyfile",return:ghostCache.rawKey};return d&&d(e),e}}if("encrypt"===r){if(!o&&!a)throw new Error("GhostCrypt: File or content required for encryption");if(!s||!["password","keyfile"].includes(s))throw new Error("GhostCrypt: Valid keyMethod required (password or keyfile)");if("password"===s&&!n)throw new Error('GhostCrypt: Password required when keyMethod is "password"');let e;if(a){const e=(new TextEncoder).encode(a);ghostCache.uploadedFile={name:null,type:"text/plain",size:e.byteLength,lastModified:Date.now(),content:e.buffer}}else if(o&&"object"==typeof o&&o.content instanceof ArrayBuffer)ghostCache.uploadedFile={name:o.name||"file",type:o.type||"application/octet-stream",size:o.size||o.content.byteLength,lastModified:o.lastModified||Date.now(),content:o.content};else if(o instanceof File)e=await readFileAsArrayBuffer(o),ghostCache.uploadedFile={name:o.name,type:o.type,size:o.size,lastModified:o.lastModified,content:e};else{if(!(o instanceof ArrayBuffer))throw new Error("GhostCrypt: File must be File object, ArrayBuffer, or ghost upload result");ghostCache.uploadedFile={name:"file",type:"application/octet-stream",size:o.byteLength,lastModified:Date.now(),content:o}}if(encryptionAgent("setKeyMethod","password"===s?0:1),"password"===s)ghostCache.rawKey=n;else if("keyfile"===s)if(c){ghostCache.keyfileContent=c;if(!decryptionAgent("loadKeyfile"))throw new Error("GhostCrypt: Invalid keyfile format");ghostCache.rawKey=ghostCache.enteredKey}else encryptionAgent("generateKeyfile");await encryptionAgent("keyDerivation"),encryptionAgent("generateIvs"),encryptionAgent("encryptAes"),encryptionAgent("encryptChacha"),encryptionAgent("calculateHmac"),encryptionAgent("buildGhost");const t={success:!0,action:"encrypt",return:ghostCache.ghost.buffer.slice(ghostCache.ghost.byteOffset,ghostCache.ghost.byteOffset+ghostCache.ghost.byteLength)};return"keyfile"===s&&ghostCache.generatedKeyfile&&(t.keyfile=ghostCache.generatedKeyfile),d&&d(t),t}if("decrypt"===r){if(!o&&!a)throw new Error("GhostCrypt: File or content required for decryption");if(!s||!["password","keyfile"].includes(s))throw new Error("GhostCrypt: Valid keyMethod required (password or keyfile)");if("password"===s&&!n)throw new Error('GhostCrypt: Password required when keyMethod is "password"');if("keyfile"===s&&!c)throw new Error('GhostCrypt: Keyfile required when keyMethod is "keyfile"');const e=!!a;let t,r;if(a){if(!(a instanceof ArrayBuffer))throw new Error("GhostCrypt: Content for decryption must be ArrayBuffer");ghostCache.uploadedFile={name:null,type:"application/octet-stream",size:a.byteLength,lastModified:Date.now(),content:a}}else if(o&&"object"==typeof o&&o.content instanceof ArrayBuffer)ghostCache.uploadedFile={name:o.name||"file.ghost",type:o.type||"application/octet-stream",size:o.size||o.content.byteLength,lastModified:o.lastModified||Date.now(),content:o.content};else if(o instanceof File)t=await readFileAsArrayBuffer(o),ghostCache.uploadedFile={name:o.name,type:o.type,size:o.size,lastModified:o.lastModified,content:t};else{if(!(o instanceof ArrayBuffer))throw new Error("GhostCrypt: File must be File object, ArrayBuffer, or ghost upload result");ghostCache.uploadedFile={name:"file.ghost",type:"application/octet-stream",size:o.byteLength,lastModified:Date.now(),content:o}}if(encryptionAgent("setKeyMethod","password"===s?0:1),!decryptionAgent("parseGhost"))throw new Error(ghostCache.error||"Ghost file could not be read");if("keyfile"===s){if(ghostCache.keyfileContent=c,!decryptionAgent("loadKeyfile"))throw new Error(ghostCache.error||"Keyfile could not be loaded")}else ghostCache.enteredKey=n;if(await decryptionAgent("deriveKeys"),!decryptionAgent("verifyHmac"))throw new Error(ghostCache.error||"Wrong password or keyfile");if(decryptionAgent("decryptChacha"),decryptionAgent("decryptAes"),e){r=(new TextDecoder).decode(ghostCache.decryptedLayer2)}else{r=ghostCache.decryptedLayer2.buffer.slice(ghostCache.decryptedLayer2.byteOffset,ghostCache.decryptedLayer2.byteOffset+ghostCache.decryptedLayer2.byteLength)}const i={success:!0,action:"decrypt",return:r};return d&&d(i),i}}catch(e){const t=e.message||"Unknown error";return ghostCache.error=t,h&&h(t),{success:!1,action:r,error:t}}finally{i&&(window.updateStatus=l)}}function readFileAsArrayBuffer(e){return new Promise(((t,r)=>{const o=new FileReader;o.onload=e=>t(e.target.result),o.onerror=e=>r(e),o.readAsArrayBuffer(e)}))}function downloadFile(e,t){const r=new Blob([e]),o=URL.createObjectURL(r),a=document.createElement("a");a.href=o,a.download=t,a.click(),URL.revokeObjectURL(o)}let ghostCache={status:"RESET",uiStatus:"Ready",lastUiUpdate:0,error:null,uploadedFile:null,uploadedKeyfile:null,cryptAction:null,chosenKeyMethod:null,rawKey:null,enteredKey:null,keyfileContent:null,generatedKeyfile:null,derivedKeys:null,ivs:null,encryptedLayer1:null,encryptedLayer2:null,decryptedLayer1:null,decryptedLayer2:null,hmac:null,ghost:null,ghostParsed:null};function updateStatus(e,t){ghostCache.status=e;const r=Date.now();r-ghostCache.lastUiUpdate>=2e3&&(ghostCache.uiStatus=t,ghostCache.lastUiUpdate=r)}function ghostcryptUploadFile(){return new Promise(((e,t)=>{let r=document.createElement("input");r.type="file",r.onchange=function(r){const o=r.target.files[0];if(o){const r=new FileReader;r.onload=function(t){ghostCache.uploadedFile={name:o.name,type:o.type,size:o.size,lastModified:o.lastModified,content:t.target.result},processFile(),e(ghostCache.uploadedFile)},r.onerror=function(e){t(new Error("File read error: "+e))},r.readAsArrayBuffer(o)}else t(new Error("No file selected"))},r.click()}))}function ghostcryptUploadKeyfile(){return new Promise(((e,t)=>{let r=document.createElement("input");r.type="file",r.accept=".gkey",r.onchange=function(r){const o=r.target.files[0];if(o){if(!o.name.endsWith(".gkey"))return void t(new Error("Invalid file type. Please select a .gkey file"));const r=new FileReader;r.onload=function(t){const r={name:o.name,type:o.type,size:o.size,lastModified:o.lastModified,content:t.target.result};ghostCache.uploadedKeyfile=r,e(r)},r.onerror=function(e){t(new Error("Keyfile read error: "+e))},r.readAsArrayBuffer(o)}else t(new Error("No keyfile selected"))},r.click()}))}function processFile(){ghostCache.uploadedFile.name.endsWith(".ghost")?ghostCache.cryptAction="decrypt":ghostCache.cryptAction="encrypt"}function generateRandomBytes(e){return crypto.getRandomValues(new Uint8Array(e))}function wordArrayToUint8(e){const t=e.words,r=e.sigBytes,o=new Uint8Array(r);for(let e=0;e<r;e++)o[e]=t[e>>>2]>>>24-e%4*8&255;return o}const keyMethods=["password","keyfile"];function encryptionAgent(e,t){return"initialize"===e?(ghostCache={status:"RESET",uiStatus:"Ready",lastUiUpdate:0,error:null,uploadedFile:null,uploadedKeyfile:null,cryptAction:null,chosenKeyMethod:null,rawKey:null,enteredKey:null,keyfileContent:null,derivedKeys:null,ivs:null,encryptedLayer1:null,encryptedLayer2:null,decryptedLayer1:null,decryptedLayer2:null,hmac:null,ghost:null,ghostParsed:null},!0):"uploadFile"===e?(ghostcryptUploadFile(),!0):"setKeyMethod"===e?(ghostCache.chosenKeyMethod=keyMethods[t],!0):"generateKeyfile"===e?generateKeyfile():"keyDerivation"===e?keyDerivation():"generateIvs"===e?generateIvs():"encryptAes"===e?encryptAes():"encryptChacha"===e?encryptChacha():"calculateHmac"===e?calculateHmac():"buildGhost"===e?buildGhost():"downloadGhost"===e?downloadGhost():"parseGhost"===e?parseGhost():"loadKeyfile"===e?loadKeyfile():"deriveKeysDecrypt"===e?deriveKeysDecrypt():"verifyHmac"===e?verifyHmac():"decryptChacha"===e?decryptChacha():"decryptAes"===e?decryptAes():"downloadDecrypted"===e?downloadDecrypted():void 0}function generateKeyfile(){const e=generateRandomBytes(64),t=btoa(String.fromCharCode(...e)),r=CryptoJS.SHA256(CryptoJS.lib.WordArray.create(e)).toString(CryptoJS.enc.Hex),o=new Uint8Array(r.match(/.{2}/g).map((e=>parseInt(e,16)))),a=new Uint8Array([71,75,69,89,33]),s=new Uint8Array([1]),n=new Uint8Array(102);return n.set(a,0),n.set(s,5),n.set(e,6),n.set(o,70),ghostCache.generatedKeyfile=n,ghostCache.rawKey=t,!0}async function keyDerivation(){if(updateStatus("KEY_DERIVATION","Deriving keys..."),!ghostCache.rawKey||0===ghostCache.rawKey.length)throw ghostCache.status="INVALID_KEY",ghostCache.error="Password or keyfile is empty",new Error("Password or keyfile is empty");const e=generateRandomBytes(32),t=ghostCache.rawKey,r=(await argon2.hash({pass:t,salt:e,time:3,mem:65536,hashLen:96,parallelism:4,type:argon2.ArgonType.Argon2id})).hash,o={aesKey:r.slice(0,32),chachaKey:r.slice(32,64),hmacKey:r.slice(64,96),salt:e};return ghostCache.derivedKeys=o,updateStatus("KEYS_DERIVED","Keys ready"),!0}function generateIvs(){updateStatus("GENERATING_IVS","Initializing...");const e={aesIv:generateRandomBytes(16),chachaNonce:generateRandomBytes(12)};return ghostCache.ivs=e,updateStatus("IVS_GENERATED","Initialization complete"),!0}function encryptAes(){if(updateStatus("ENCRYPTING_AES","Ghost is emerging..."),!ghostCache.uploadedFile||!ghostCache.uploadedFile.content)throw new Error("No file content to encrypt");if(!ghostCache.derivedKeys||!ghostCache.ivs)throw new Error("Keys or IVs not initialized");const e=new Uint8Array(ghostCache.uploadedFile.content),t=CryptoJS.lib.WordArray.create(e),r=CryptoJS.lib.WordArray.create(ghostCache.derivedKeys.aesKey),o=CryptoJS.lib.WordArray.create(ghostCache.ivs.aesIv),a=wordArrayToUint8(CryptoJS.AES.encrypt(t,r,{iv:o,mode:CryptoJS.mode.CBC,padding:CryptoJS.pad.Pkcs7}).ciphertext);return ghostCache.encryptedLayer1=a,updateStatus("AES_ENCRYPTED","Ghost is getting stronger..."),!0}function encryptChacha(){if(updateStatus("ENCRYPTING_CHACHA","Ghost is being reinforced..."),!ghostCache.encryptedLayer1)throw new Error("Layer 1 encryption not completed");const e=ghostCache.encryptedLayer1,t=ghostCache.derivedKeys.chachaKey,r=ghostCache.ivs.chachaNonce,o=ChaCha20.encrypt(t,r,e);return ghostCache.encryptedLayer2=o,updateStatus("CHACHA_ENCRYPTED","Ghost is protected"),!0}function calculateHmac(){updateStatus("CALCULATING_HMAC","Ghost is being sealed...");const e=CryptoJS.lib.WordArray.create(ghostCache.derivedKeys.salt),t=CryptoJS.lib.WordArray.create(ghostCache.ivs.aesIv),r=CryptoJS.lib.WordArray.create(ghostCache.ivs.chachaNonce),o=CryptoJS.lib.WordArray.create(ghostCache.encryptedLayer2),a=CryptoJS.lib.WordArray.create().concat(e).concat(t).concat(r).concat(o),s=CryptoJS.lib.WordArray.create(ghostCache.derivedKeys.hmacKey),n=wordArrayToUint8(CryptoJS.HmacSHA512(a,s));return ghostCache.hmac=n,updateStatus("HMAC_CALCULATED","Ghost sealed"),!0}function buildGhost(){updateStatus("BUILDING_GHOST","Ghost is materializing...");const e=new Uint8Array([71,72,79,83,84]),t=new Uint8Array([1]),r=ghostCache.derivedKeys.salt,o=ghostCache.ivs.aesIv,a=ghostCache.ivs.chachaNonce,s=ghostCache.encryptedLayer2,n=ghostCache.hmac,c=e.length+t.length+r.length+o.length+a.length+s.length+n.length,i=new Uint8Array(c);let h=0;return i.set(e,h),h+=e.length,i.set(t,h),h+=t.length,i.set(r,h),h+=r.length,i.set(o,h),h+=o.length,i.set(a,h),h+=a.length,i.set(s,h),h+=s.length,i.set(n,h),ghostCache.ghost=i,updateStatus("GHOST_BUILT","Ghost is ready"),!0}function downloadGhost(){updateStatus("DOWNLOADING_GHOST","Ghost is being released...");const e=new Blob([ghostCache.ghost],{type:"application/octet-stream"}),t=ghostCache.uploadedFile.name+".ghost",r=URL.createObjectURL(e),o=document.createElement("a");return o.href=r,o.download=t,o.click(),URL.revokeObjectURL(r),updateStatus("ENCRYPTION_COMPLETE","Ghost unleashed! ðŸ‘»"),!0}function decryptionAgent(e){if("parseGhost"===e)return parseGhost();if("loadKeyfile"===e)return loadKeyfile();if("deriveKeys"===e)return deriveKeysDecrypt();if("verifyHmac"===e){return!!verifyHmac()||(ghostCache.status="WRONG_KEY",ghostCache.error="Wrong password or keyfile",!1)}return"decryptChacha"===e?decryptChacha():"decryptAes"===e?decryptAes():"download"===e?downloadDecrypted():void 0}function parseGhost(){updateStatus("PARSING_GHOST","Reading ghost...");const e=new Uint8Array(ghostCache.uploadedFile.content);if(e.length<131)return ghostCache.status="INVALID_FILE",ghostCache.error="File too small to be a valid .ghost file",!1;let t=0;const r=e.slice(t,t+5);t+=5;const o=String.fromCharCode(...r);if("GHOST"!==o)return ghostCache.status="INVALID_FILE",ghostCache.error="Invalid .ghost file - wrong magic number",!1;const a=e[t];if(t+=1,1!==a)return ghostCache.status="UNSUPPORTED_VERSION",ghostCache.error=`Unsupported .ghost version ${a}`,!1;const s=e.slice(t,t+32);t+=32;const n=e.slice(t,t+16);t+=16;const c=e.slice(t,t+12);t+=12;const i=e.length-t-64;if(i<1)return ghostCache.status="INVALID_FILE",ghostCache.error="Invalid .ghost file - no encrypted data",!1;const h=e.slice(t,t+i);t+=i;const d=e.slice(t,t+64);return 64!==d.length?(ghostCache.status="INVALID_FILE",ghostCache.error="Invalid .ghost file - incomplete HMAC",!1):(ghostCache.ghostParsed={magic:o,version:a,salt:s,aesIv:n,chachaNonce:c,encryptedData:h,hmac:d},ghostCache.status="GHOST_PARSED",!0)}function loadKeyfile(){try{const e=new Uint8Array(ghostCache.keyfileContent);if(e.length<102)return ghostCache.status="INVALID_KEYFILE",ghostCache.error="Invalid .gkey file: file too small",!1;if(71!==e[0]||75!==e[1]||69!==e[2]||89!==e[3]||33!==e[4])return ghostCache.status="INVALID_KEYFILE",ghostCache.error="Invalid .gkey file: wrong file format",!1;const t=e[5];if(1!==t)return ghostCache.status="INVALID_KEYFILE",ghostCache.error=`Invalid .gkey file: unsupported version ${t}`,!1;const r=e.slice(6,70),o=btoa(String.fromCharCode(...r));return ghostCache.enteredKey=o,ghostCache.status="KEYFILE_LOADED",!0}catch(e){return ghostCache.status="KEYFILE_PARSE_ERROR",ghostCache.error="Keyfile could not be read",!1}}async function deriveKeysDecrypt(){if(updateStatus("DERIVING_KEYS_DECRYPT","Verifying keys..."),!ghostCache.enteredKey||0===ghostCache.enteredKey.length)throw ghostCache.status="INVALID_KEY",ghostCache.error="Password or keyfile is empty",new Error("Password or keyfile is empty");const e=ghostCache.ghostParsed.salt,t=ghostCache.enteredKey,r=(await argon2.hash({pass:t,salt:e,time:3,mem:65536,hashLen:96,parallelism:4,type:argon2.ArgonType.Argon2id})).hash,o={aesKey:r.slice(0,32),chachaKey:r.slice(32,64),hmacKey:r.slice(64,96),salt:e};return ghostCache.derivedKeys=o,ghostCache.ivs={aesIv:ghostCache.ghostParsed.aesIv,chachaNonce:ghostCache.ghostParsed.chachaNonce},ghostCache.status="KEYS_DERIVED",!0}function verifyHmac(){updateStatus("VERIFYING_HMAC","Verifying seal...");const e=ghostCache.ghostParsed.hmac;if(!e||64!==e.length)return ghostCache.status="HMAC_INVALID",ghostCache.error="Invalid or corrupted HMAC",!1;const t=CryptoJS.lib.WordArray.create(ghostCache.ghostParsed.salt),r=CryptoJS.lib.WordArray.create(ghostCache.ghostParsed.aesIv),o=CryptoJS.lib.WordArray.create(ghostCache.ghostParsed.chachaNonce),a=CryptoJS.lib.WordArray.create(ghostCache.ghostParsed.encryptedData),s=CryptoJS.lib.WordArray.create().concat(t).concat(r).concat(o).concat(a),n=CryptoJS.lib.WordArray.create(ghostCache.derivedKeys.hmacKey),c=wordArrayToUint8(CryptoJS.HmacSHA512(s,n));let i=0;for(let t=0;t<64;t++)i|=c[t]^e[t];return 0!==i?(ghostCache.status="HMAC_FAILED",ghostCache.error="Wrong password or corrupted file",!1):(ghostCache.status="HMAC_VERIFIED",!0)}function decryptChacha(){if(updateStatus("DECRYPTING_CHACHA","Ghost is being freed..."),!ghostCache.ghostParsed||!ghostCache.ghostParsed.encryptedData)throw new Error("No encrypted data to decrypt");if(!ghostCache.derivedKeys||!ghostCache.ivs)throw new Error("Keys not derived yet");const e=ghostCache.ghostParsed.encryptedData,t=ghostCache.derivedKeys.chachaKey,r=ghostCache.ivs.chachaNonce,o=ChaCha20.decrypt(t,r,e);return ghostCache.decryptedLayer1=o,ghostCache.status="CHACHA_DECRYPTED",!0}function decryptAes(){if(updateStatus("DECRYPTING_AES","Ghost is being revealed..."),!ghostCache.decryptedLayer1)throw new Error("Layer 1 decryption not completed");const e=ghostCache.decryptedLayer1,t=CryptoJS.lib.WordArray.create(e),r=CryptoJS.lib.WordArray.create(ghostCache.derivedKeys.aesKey),o=CryptoJS.lib.WordArray.create(ghostCache.ivs.aesIv),a=CryptoJS.lib.CipherParams.create({ciphertext:t}),s=wordArrayToUint8(CryptoJS.AES.decrypt(a,r,{iv:o,mode:CryptoJS.mode.CBC,padding:CryptoJS.pad.Pkcs7}));if(0===s.length)throw new Error("Decryption failed - wrong password or corrupted file");return ghostCache.decryptedLayer2=s,ghostCache.status="DECRYPTION_COMPLETE",!0}function downloadDecrypted(){updateStatus("DOWNLOADING_DECRYPTED","Ghost reveals its secret...");const e=new Blob([ghostCache.decryptedLayer2],{type:"application/octet-stream"});let t=ghostCache.uploadedFile.name;t.endsWith(".ghost")&&(t=t.slice(0,-6));const r=URL.createObjectURL(e),o=document.createElement("a");return o.href=r,o.download=t,o.click(),URL.revokeObjectURL(r),updateStatus("DECRYPTION_COMPLETE","Ghost decrypted! ðŸ”“"),!0}
   

   
   // ***************************************************************************************** \\